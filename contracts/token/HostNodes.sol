pragma solidity ^0.4.4;

import "./GameToken.sol";
import "../game/Game.sol";

/**
 * @title Basic HostNodes
 *
 * @dev Plural because this manages multiple Nodes/HostNodes 
 *
 * @author Stijn Bernards
 */
contract HostNodes {

    /**
     * @dev node struct.
     */
    struct Node {
        uint256 ID;
        bool active;
        bool assigned;
        string ipAddress;
        address hoster;
        uint256 levy;
    }

    mapping(address => Node) public nodes;
    mapping(uint256 => address) public nodeAddresses;
    uint256 private currentNodeIndex;
    GameToken private gameToken;
    uint256 private requiredHostBalance;

    event NodeRegister(address indexed registeredNode, string ipAddress); //Node Registry event
    event NodeRemoval(address indexed removedNode, string ipAddress); //Node removal event
    event NodeAssigned(address indexed assignedNode, address game); //Node Assigning

    /**
     * @dev Checks if node is active
     * 
     * @param _hoster The sender / hoster
     */
    modifier onlyHostNode(
        address _hoster
    )
    {
        require(
            nodes[_hoster].active,
            "Hostnode is not active"
        );
        _;
    }

    /**
     * @dev HostNode Initialization
     * 
     * @param _gameToken gameToken address
     * @param _requiredHostBalance Required hostNode balance
     */
    constructor(
        GameToken _gameToken,
        uint256 _requiredHostBalance
    ) public
    {
        gameToken = _gameToken;
        requiredHostBalance = _requiredHostBalance;
    }

    /**
     * @dev registers a hostNode to the network
     * 
     * @param _ipAddress hostNode IP Address
     *
     * @return uint256 The nodeID
     */
    function registerHostNode(
        string memory _ipAddress
    ) public returns (uint256)
    {
        require(
            gameToken.balanceOf(msg.sender) >= requiredHostBalance,
            "Hostnode has insufficient balance"
        );

        emit NodeRegister(msg.sender, _ipAddress);

        //Check if node exists, if it does only change ipAddress
        if (nodes[msg.sender].active) {
            nodes[msg.sender].ipAddress = _ipAddress;

            return nodes[msg.sender].ID;
        } else {
            nodeAddresses[currentNodeIndex] = msg.sender;

            nodes[msg.sender] = Node({
                ID: currentNodeIndex,
                active: true,
                assigned: false,
                ipAddress: _ipAddress,
                hoster: msg.sender,
                levy: 5 //Hardcoded for now
            });
   
            currentNodeIndex++;

            return currentNodeIndex - 1;
        }
    }

    /**
     * @dev assign a hostNode to the given Game
     * 
     * @param _game The game contract address
     * @param _hostNodeID The host node ID
     *
     * @return uint The hostNode ID
     */
    function assignHostNodeToGame(
        address _game,
        uint256 _hostNodeID
    ) public returns (uint)
    {
        Node storage node = nodes[nodeAddresses[_hostNodeID]];

        require(
            node.active,
            "This node is not active!"
        );
        require(
            !node.assigned,
            "This node has already been assigned to a game"
        );

        Game game = Game(_game);

        //Final check is being done in the Game contract
        uint nodeID = game.assignNode(
            node.ipAddress,
            node.hoster,
            node.levy,
            node.ID    
        );

        node.assigned = true;

        return nodeID;
    }

    /**
     * @dev Removes a hostNode from the Game
     *
     * @param _game the Game
     * @param _hostNodeID The hostnode to remove
     *
     * @return bool success
     */
    function removeHostNodeFromGame(
        address _game,
        uint256 _hostNodeID
    ) public onlyHostNode(msg.sender) returns (bool)
    {
        Node storage node = nodes[nodeAddresses[_hostNodeID]];

        require(
            node.assigned,
            "Node has not been assigned"
        );

        Game game = Game(_game);

        game.removeNode(node.hoster, _hostNodeID);

        node.assigned = false;

        delete nodeAddresses[_hostNodeID];

        return true;
    }

    /**
     * @dev Remove the current HostNode from the nodeMapping
     *
     * @return bool Success
     */
    function removeHostNode() public returns (bool) {
        require(
            nodes[msg.sender].active,
            "Hostnode is not active"
        );

        emit NodeRemoval(msg.sender, nodes[msg.sender].ipAddress);
        
        delete nodeAddresses[nodes[msg.sender].ID];
        delete nodes[msg.sender];

        return true;
    }

    /**
     * @dev Retrieve a node from the nodes list
     *
     * @param _nodeID Index of addressIndex generated by calling size and then looping over the number.
     *
     * @return string The node ipAddress
     */
    function getNodeAddress(
        uint _nodeID
    ) public view returns (string memory) 
    {
        return nodes[nodeAddresses[_nodeID]].ipAddress;
    }
}